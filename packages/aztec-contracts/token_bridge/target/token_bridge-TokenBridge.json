{"transpiled":true,"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"TokenBridge","functions":[{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83YS2/TQBAH8HXSpi2JX3k1duzESWxy4EIPcOTIEXFGQoiXKgQCIcoBPiKfip3ZHf/jGiwtqiIsOXZn55cZb2xroVR9pc71rlSu7NbTERWogT54tD9RcmYGlRcoT0IVDbKqbJrqb/XHvUq+qveIBtiFFDvhz9MHfE5neh+UyiN6ckrfTKXNUEntKQIXlbR3pjhI2wV9mBxi5yVG9Bc+ozZM8plNHlY9E1RDsKHJuTCnTL8gLHTElBJGoCPQkaU3CAv1mVKCD+qD+pYWCAsNmFJCABqABpZ+QFhoyJQSQtAQNLT0M8JCI6aUEIFGoJE5tkngTkZ3XkVf02uEhcZMKSEGjUFjSz8hLHTMlBLGoGPQcbvRcd1oB9HVfiIsdMKUEiagE9CJpe8RFjplSglT0Cno1NJ3CAudMaWEGegMdEbHDT1aN3gwI4YKT6M8fpStKnlE9TeeKGxzLjVvlro0eGZOZYRuwUskJXjA0wGfpjZ/aV8gmceJGYVo546/mr/kcslklaQtUNgM9EyQBqVCQkd6Oq8P2rrV8GNP7kHbyql5l/XxiqPTh4132fyv77JZ8132FBXnNnnBnVLtBdgCv9jC0u8IC03qi0wOJhc0wa/ZJGE30dXeIiw0ZcpzCJqCpu1qaf1qcCSBOxm6k9Cd+N1Ez9w1wkKXTFNzfwtdgi7b1Zb1K8CRjLqJbvAVwkLN00IJGWgGmrWrZXU1RzLsJrrBjwgLzZlSQg6ag+btank9g44kdCe+O0ncSfS/XsvwKI3F3UTfOD8QFrpiSgkr0BXoql1tVU9DB9HV3iAsdM2UEtaga9B1u9q6vk0die9OEncSuZP4KOQfZmx655Os74JvCAstmFJCAVqAFu1qRf02dSTRUaoE7iQ5yrXERyF5N6HFqfcSa8Mrhn9YTheN5XTRXE5vuNSmWWprcGFOZYQWn1sklVhjVmY5Xdn8+3YNuzfL6T2FaOeOX5i/5HLJ7CtJ26GwGeiZIA1KhZKOOsN7ftDWrYbr5fRVycvnw42X1fwfFGz6B5ddz94As7dtrqw3+56FHqaett3BzJjp2EmzfN30b+yK+7Jb39ThtIpnoKp72PIvo+wv09vR6eIX7b8B3hwxh3MRAAA=","debug_symbols":"5ZzdSlxJGEXfpa9lOLV3/eZVhmEwiRkE0RDNwCB599GxWzPYJCzCDhivpO36ijou1s2yOLe792dvP//15/nlh6vr3Zvfb3cXV+9Ob86vLu8+3e6238r232+vP55e3v/i+ub0083uzXayO7t8f/fzy8nuw/nF2e5N619Oni1bre0XrjEelxbXI2ur1feLq90eV98PPlvca1v7xb2O/y3+4+T+1OUHTl02a7+ybK3+1HPrR/7aqzwdu33n2EVbPaxW37597NHX2C8eo27Pj+3MsR82r8nNW3Lzntx8JDefyc1XcHNtyc1LcnMlN08aqqShShqqpKFKGqqkoUoa6qShThrqpKFOGuqkoU4a6qShThrqpKFOGlqThtakoTVpaE0aWpOG1qShNWloTRpak4bWpKEtaWhLGtqShrakoS1paEsa2pKGtqShLWloSxrak4b2pKE9aWhPGtqThvakoT1paE8a2pOG9qShI2noSBo6koaOpKEjaehIGjqSho6koSNp6EgaOpOGzqShM2noTBo6k4bOpKEzaehMGjqThs6koStp6EoaupKGrqShK2noShq6koaupKEraehKGlq2Lbp7ie6u6O7RWwtbje4evbewRS8ubNGbC1v06sIWdbVEXS1RV0vU1ewNo+wVo+wdI3DJaD8w6MCkAwsOgEs7+4FCB0QHTAcqHWh0gJIWJS1KWpS0KWlT0qakTUmbkjYlbUralLQpaVPSlZKulHSlpCslXSnpSklXSrpS0pWSrpR0o6QbJd0o6UZJN0q6UdKNkm6UdKOkGyXdKelOSXdKulPSnZLulHSnpDsl3SnpTkkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKTkp6U9KSkJyU9KelJSU9KelLSk5KelPSipBclvSjpRUkvSnpR0ouSXpT0oqQXJK1towOFDogOmA5UOtDoQKcDgw5MOkBJF0q6UNKFki6UdKGkCyVNG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSR+XgjG26Hl2sOD309duQllWU7vHeylFYeF5d27C2Vrc3D6tb1tPXRV1q26sfFtfvbi+doh3d8zrmVrxc/POvxWveLPqte0bP6FT1rfUXP2l7Rs/af/qxDT8/6neOX0p+2Hv1x8V37PJx/vPDzzxd+/vWyz3/8HzIv6PzlhZ9fL/b8d5/+Pv10fvr24uz+dfj3X36+fHd4O/7dx5t/Pj58c7f2Xw=="},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/82YyY7bRhCGW5oZzUSRuGgbZSRK1EJpLNmxZ4D4FOeYY065B9ngBNkQxzkkCBAg5wB5gLyRn8pdVV38KdOm0YJBDAGSrer/Y1VXL+jW2pwYc2FvYxLjLrKYwLTsq0H3J0ZLttC0dyMwDTVlVElUM3Myc8IlEp4u7aP9kVEXIT3O+Nnac5lK9j5fmwahZ2f0ZXOuVWsKhrF2puFdcIR8tekhGsLeW6PGfvAz+35fxBdO3MmaYjQdYB3RtKXI6C8wK9pllARdoF2gXYc+h1nRgFESBEADoIFDU5gVDRklQQg0BBo69HuYFY0YJUEENAIaOfRnmBWNGSVBDDQGGsu7jIT+SPede7Ft+hJmRXuMkqAHtAe059AfYVa0zygJ+kD7QPvlQPt5oBWI9fYnzIoOGCXBAOgA6MCh38Ks6JBREgyBDoEOHfoNzIqOGCXBCOgI6IjeC5pazzExIwYNZqNOP1KbTKeo/eKpwXXJri4PXY0FHklRayiBY4iuMMEnLS5OnH7qFpCkwUJay6Z0c8S/yi9tLjFJprIP4FgqmmKkSvVwRW+anU8LYb0S8OOGzisaY+ZcVrkzWd7cMncp+MfE5GkbIW3jw/WsjebaJDQ+PYyWxFd5tFeFLIlm7AIn9HeYFZ0wyi0DOgE6Kbdxki8LFYj19jXMik4ZnUhPKToFOi17m+bLgycS+iMdfyTyR4JqxGbuC5gVlQFJggRoAjQpe0vypa4Csd5+g1nRGaMkmAGdAZ2VvR2NDKoRG+AzmBWdM0qCOdA50HnZ2zwfSJ7ItBYvnWrEpuEHmBVNGSVBCjQFmpa9pXnSPZHIH5n6I6E/ktQS2BFe4mrEdulPMCu6YJQEC6ALoIuyt0XepZ5I4I9M/JHYH4lqaUunlsB61YgdBX/ArOiSURIsgS6BLsvelnkaKhDr7SuYFV0xSoIV0BXQVdnbKh9znkjgj0z8kdgf6dWCHJGxYS1JDv2RyB/p1pKxWS1tubNjbFGNUHXjP5xDnjBocPjQ08YqP76N5YvF49uaXa0PXWUCrxy3wkEng2iL88y1HN+unf6eO77t5Pi2IxPdHPG/8kubS8wuU9kGjqWiKUaqVA9beqf2S/8Uwnol4MfuEGqerPmvp+JFVS3+Q0zuwqk1z975G09xl9umA/mvLeSgkJmNpCNzsW+53f9TieNy14n4YdmWM0AtG8sZk7yeom8f0adeF93mMLpCn2xsJ3wuKVNPJL7HKb2WXlLM9cfGddTmdUjHH5n7IwN/JPJHAn8k9keGtSCzWpKc1IIc0S/hXQ0sqmWKdWtpy1u82JXmO5gVlcWbBDugO6C7srddPjw9kcAfSfyR2B9J72rz41oyVk+/DGpBolqaH97VwI7ol64/0vFHZu988Nv17CnMiu4ZJcEe6B7ovuxtn4+1CoR2h82/sde7YdBgg6c7un2+j9/IF4v7+Pvs6v6hqwcC76WoNbSZfADRQ+wZH7UgoEjcPv5W9vG3Lrgbjvgv+aXNJeY2U9mHcCwVTTFSpXp4SO/UfunZuuj1IGDeL1Nrb/hkM35B90uy996P5h4AAA==","debug_symbols":"5dzhih7HFYThe9nfIkyf6nO627cSQpBtOQiEZCw5EITvPSt7d+WgxcpbyjFs9MusND3M56oS4tHsvr/5/sW3P//j7y9f//Dm7c03f31/8+rNd8/fvXzz+var9zfXX8b166++/fH56w+/8Pbd85/e3XxzPbt58fr72//+8uzmh5evXtx8k/XLs08uO5l3F561Hi4dmo9cOxV1d/GU8uHqDwc/ubhmnruLa67/uPhvzz489fiCpx6X4u7KceX8U587vuT/9hkfHzs/89gjrnl/ddT1x4+96qy7i9ea16ePrZ7H/u3ms/Pm2Xnz6rz56rz57rz5abx5XJ03H503j86bdy40OhcanQuNzoVG50Kjc6HRuVB1LlSdC1XnQtW5UHUuVJ0LVedC1blQdS5UnQudnQudnQudnQudnQudnQudnQudnQudnQudnQudnQvNzoVm50Kzc6HZudDsXGh2LjQ7F5qdC83OhWbnQqtzodW50OpcaHUutDoXWp0Lrc6FVudCq3Oh1bnQ1bnQ1bnQ1bnQ1bnQ1bnQ1bnQ1bnQ1bnQ1bnQ1bnQ3bnQ3bnQ3bnQ3bnQ3bnQ3bnQ3bnQ3bnQ3bnQ3bnQ07nQ07nQ07nQ07nQ07nQ07nQ07nQ07nQ07nQ07nQcV2tdx+td4/Wu7e+tXDN1ru3vrdwtb64cLW+uXC1vrpwtW51tG51tG51tG619w2j3leMet8x+qKXjObc9++jzXk+vqL3+MtrNe5vWxWPvXT3JcP+H7//99//KXB34MAD4EWjuwODHgh6QPTApAeSHih6YNEDNOmgSYsmLZq0aNKiSYsmLZq0aNKiSYsmLZr0pElPmvSkSU+a9KRJT5r0pElPmvSkSU+adNKkkyadNOmkSSdNOmnSSZNOmnTSpJMmXTTpokkXTbpo0kWTLpp00aSLJl006aJJL5r0okkvmvSiSS+a9KJJL5r0okkvmvSiSW+a9KZJb5r0pklvmvSmSW+a9KZJb5r0pkkfmvShSR+a9KFJH5r0oUkfmvShSR+a9IFJx3XRA4MeCHpA9MCkB5IeKHpg0QObHqBJD5r0oEkPmvSgSQ+a9KBJD5r0oElTIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokYmamSiRiZqZKJGJmpkokamx41sjXX/k+XXOPn7Y4/8qPNx3f/08jFyPFw88rFvLcvc91dnRTxc/ej3oeXUw8Wz9McX75X33+G29zV+f/Gvn3U+rnX/p581vqLPqq/os86v6LPmV/RZ60//rCs+ftbPPP4Y9fHWqx4uvv3X6PvnX0/8+fcTf/7ztJ//8X+QeULPP57488cTf/7P/h0grvzkr79zTO9YesfKO7a8Y9s7dqxjcXnHhncsvGNeS8JrSXgtCa8l4bUkvJaE1xJ5LZHXEnktkdcSeS2R1xJ5LZHXEnktkdeS6bVkei2ZXkum15LptWR6LZleS6bXkum1ZHotSa8l6bUkvZak15L0WpJeS9JrSXotSa8l6bWkvJaU15LyWlJeS8prSXktKa8l5bWkvJaU15LltWR5LVleS5bXkuW1ZHktWV5LlteS5bVkeS3ZXku215LttWR7LdleS7bXku21ZHst2V5LtteS47XkeC05XkuO15LjteR4LTleS47XkuO15Fgtyevyjg3vWHjH5B2b3rH0jpV3bHnHtnfMa8nwWjK8lgyvJZ69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrefZanr2WZ6/l2Wt59lqevZZnr+XZa3n2Wp69lmev5dlrefZanr2WZ6/l2Wt59lqevZZnr+XZa3n2Wp69lmev5dlrefZanr2WZ6/l2Wt59lqevZZnr+XZa3n2Wp69lmev5dlrefZanr0Wt9fbL/75/KeXz7999eLt7ZEPv/fz6+/evXzz+u7Ld//68bffub323w=="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3djhzHlYTfhdfCIs9vZupVFosFbcsLAgJlWPQChuB3d9Hqrh5iSiyOVRkTx+SVTSlZEd1kRPS0vur+5c2ffvjD3/7vf9+9//NPP7/5/r9/efPjT398++HdT++3X/3ypv2X2L/+6c9/efv+4z/4+cPbv35483377s0P7/+0/e8/vnvz53c//vDm+8h//M93H8/7C8/HC8/nC8/3F54fLzw/X3Ze2wvPyxef/+7ZsRlxOzh734+K+cFZN83bYTeL/fTH3/jscHrM2+H0/snhX13r73AtzfR2Ulo41Lf9nmd7ysN2nNgWbX4/rdk+b7vn7LfDvXt7btvX2P714rHy4rny4n3lxcfKi8+FF7e28uKy8uK68uK28uIrE2orE2orE2orE2orE2orE+orE+orE+orE+orE+orE+orE+orE+orE+orE+orExorExorExorExorExorExorExorExorExorExorE5orE5orE5orE5orE5orE5orE5orE5orE5orE5orE9pXJrSvTGhfmdC+MqF9ZUL7yoT2lQntKxPaVya0r0zoWJnQsTKhY2VCx8qEjpUJHSsTOlYmdKxM6FiZ0LEyoXNlQufKhM6VCZ0rEzpXJnSuTOhcmdC5MqFzZULnyoRKa0uvLkuvrkuvbkuv7kuvHkuvnkuv3pdefSy9+tKsytKsytKsytKsytKsytKsytKsytKsytKsytKsytKs6tKs6tKs6tKs6tKsLoWNZCltJEtxIznmjbyPO3Pmw/vnNVT6XWT7v7ofNhl3kYEQmQCRYw7pZSLa7vCfqn8qcvAHOB5/gGL7YT3k82zeryxunxy+uZfS7rW0eyvt3ku7j9Lus7T7Xtr9KO1+VnbvpbfWS2+tl95aL721XnprvfTWeumt9dJb66W31ktvbZTe2ii9tVF6a6P01kbprY3SWxultzZKb22U3toovbVZemuz9NZm6a3N0lubpbc2S29tlt7aLL21WXprs/TW9tJb29du7U1EESJXLFf2XWRM6J+Dl3Yfpd1nafe9tPtR2v2s7H600u6ltHst7b701o7SWztKb+0ovbWj9NaO0ls7Sm/tLL21s/TWztJbO0tv7Sy9tbP01s7SWztLb+0svbWz8tZqq7y12ipvrbbKW6ut8tZqq7y12ipvrbbKW6ut8tZqq7y12kpvrZTeWim9tVJ6a6X01sra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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7X3tjiTLbeW73N+CEB+ML7/KwljItrwQYEiGJS+wMPTuW8yZzO7RRHfd25WMPEzylyUrc84hoyJ4OqrI8z+//Nsf/+W//8///tOf//0vf/3ln/7X//zyH3/51z/87U9/+fPjv/3PL5G2/99f//MPf+b/+te//eG//vbLP4Xf/fLHP//b4//+/Xe//Puf/uOPv/xTqX//3U+PpZrb9ydTLeN4OOYyeTq31r8/nTuVJ0+PEsr3p0epdDyd2pg+Xb8/HEN4//Df//l3v8RiIMa6LEZKYX+aUm0LY2wvxJhHyPvKjPwWY+vbP93l/unxwj8dY6M9ISm/XxmaPf1Ymv3pkuuTp1PtY1/1HsbTlTltHVN4JSOpHxnJOT2JsYz94Zrf78a08YggPBIIjwzCg0B4FBAeFYRHA+HRQXgMDB554Xla486D2k88IgiPdedpy3udaz38xGPdeTrC/vD44dk0ebbmcOTu3WeptxmL0netF2uoPzzNEdLtIyy3j7Dqj7DGeESYy08RtttH2G8f4bhBhHT8dVZr+McIKdw+wnj7CNMdqkV9izD+FCGophn74dFyfhLh48YiHPceOfzD5QTR3QNcp2hi6MeZHqk8CbHk/er0/f3S/B8+5H/s/S0+2uKrN4+v3Ty+fvP4xr3jK+Hm8cWbx5duHl++eXx08/hurl/KzfVLubl+KTfXL+Xm+qXeXL/Um+uXenP9Um+uXyrdPL6b65d6c/1Sb65f6s31S725fmk31y/t5vql3Vy/tJvrl0Y3j+/m+qWh6peW9h9gt9zex8ekUUXJp6RRlUY/vi/vPX7+Sfr8u9aGqjVOi7Cjqo3zIkTVG+dFiKo4zosQVXOcFyHdPkJU3XFehKjK47wIUWXKeRHeXtP022uacXtNM26vacbtNc24vaYZdPsIb69pxu01zbi9phm31zTj9pomhtuLmhhur2piuL2sieH2uiYGun+It1c2Mdxe2sRwe23zgL1/iPdXN/H+6ibeX93E+6ubeH9189JISSUh3l/dxPurm3h/dRPvr27i/dVNur+6SfdXN+n+6ibdX90sHE56WYj3Vzfp/uom3V/dpPurm3R/dZPvr27y/dVNvr+6yfdXNwsH+l4W4v3VTb6/usn3Vzf5/uom31/d0P3VDd1f3dD91Q3dX90snO17WYj3VzewA35PDPH+6gZ2zO+JId5f3cAO+z0xxPurG9iRvyeGeH91Azv498QQ769uYMf/nhji/dUN7BDgE0O8v7qBHQV8Yoj3VzewA4FPDPH+6gZ2LPCJId5f3cAOBz4xxPurG9gRwSeGeH91Azso+MQQ769uYMcFnxji/dUN7NDgE0O8v7qBHR18Yoj3Vzf3H0sc7z+XOC4dTJzaRyFuVKYqJIewGy3n0PMzQnmfo/3gNt4yE/vk6fGW8hDf/uU0JZ/H4fdM+YeHN+5JMfesmDsp5l4Uc6+KuTfF3Lti7kMv9/msWyXcFdfVobiuDsV1dSiuq0NxXR2K6+pQXFeH4ro69NbVFPTW1RT01tUU9NbVFPTW1RT01tUU9NbVFPTW1RT01tUU9NbVFBTX1ai4rkbFdTUqrqtRcV2NiutqVFxXo+K6GhXX1ai4rkbFdTUprqtJcV1NiutqUlxXk+K6mhTX1aS4ribFdTUprqtJcV3NJ9TVHN/9GKku5B4Vc0+KuWfF3Ekx96KYe1XMvSnm3hVzH3q5k+K6SorrKimuq6S4rpLiukqK6yoprqukuK6S4rpKiutqUVxXi+K6WhTX1aK4rhbFdbUorqtFcV0tiutqUVxXi+K6WhXX1aq4rlbFdbUqrqtVcV2tiutqVVxXq+K6WhXX1aq4rjbFdbUprqtNcV1tiutqU1xXm+K62hTX1aa4rjbFdbWdUFdrO+jU0Z9xz+P7w6O+H4g0Njo9YNGJWHQSFp2MRWdedlLsO53HbeTndFKuO53HbfcbRKQ2ebqVfc/2/m7+Vhoz6iXsP+4bpdIP5GdPH3s2hPcPfwu0WAm0Lg708bE66HT6IdKNTwPj0xfziSUchEoZTz4KMaWjqKX8RuTxJdiMSaF+MGnx86qWaezj7PLjA/f2cJ49nEI6EhL6+4e3LA7P4utZ/GBIk2fxt2UxehZPyGLyLP6aLOajVOdHcn7KYvYsnpBF8iz+qizm46+GXOLnDz+E2JGQ/u5PjPnDOR4P5/TzWVF8fS5en7af5YlC+PzhVvb42qB/vMsY1ZfyLkvZfCnvspT+R+rFS0nxGEJPub+ylP6X8k2WMgf/c/3ipXzLRyq5/YMszcEvArDXx68YsNfHLy+w14d8fa5dn5rz/nBt6fOHY69HOnovPy2m36HcaDH9FkXRYqYQjn85pPHKXwR+5WJz3f1+xua6+2WOqnU/hsOlUPML6x795sfmuvuN0vnrPsL+L6cRn5zGn38RnaPfKF29Pid95ZWjXz7dZinJl/LapTztK6/ot1S3WUq/o7p4KT+/3Y9+l4S9Pn7ng70+fjcDvT7J71AuXp8Tv/BKfjFyo8X0WxRFi3netxnJr1xsrjv5uptcd7/MUbXuZ32Llfzmx+a6+42SwLr3o3M5xP6a7vYbJez18Rula9fnPOmT/fLpNkvpV0+3WUq/eLrNUvpd0tVLedafDdmvh26zlH7j86uWkg7WmeKTh08cpJSz38xcvT5n/egx+2XLbZbS72Vus5R+hXPxUp72+1XyK5zbLKVf4Vy8lJ//VI/8XgZ7ffyyBXt9yNcHen38WuTi9Tnx16vkdyg3Wky/RVG0mOd9fUR+5WJz3f1+xuS6F7/MUbXuZ30hWfzmx+a6+43S+et+4iCl4jdKV6/PWV95FfKlvMtS+j3VxUt52ldexW+pbrOUfkd18VJ+frtf/C4Je338zgd6farfzWCvj9+hXLw+J37hVf1i5EaL6bcoihbzvG8zKvm6m1x3v5+xue5+maNq3c/6Fqv6zY/NdfcbJYF1P29QT/UbJej1aX6jdO36nCd9ml8+3WYp/erpNkvpF0+3WUrypbx4Kc/6s6H59dBtlnL9jc/Yp0vFWoOWpXwcfkdCwk+/Mm3Ns3hCFrtn8YQsDs/i61nswbP4q2YFhqNqPZLzUxajZ/GELCbP4rUm7Z/3mPTs63Px+pzVmNDJl/IuS1l8Ke+ylP5H6sVLeVqPSfe/lG+zlP7n+sVL+fnP6btfBECvz/ArBuz18csL7PXxa5GL1+fEDpPhdyg3WkzyxdSzmOf9xGP4lYvNdff7GZvr7pc5qtb9rB8NDb/5sbnufqN0/rqfN+zw8SWLr8/F63PSV14U/PLpNkvp91QXL+VZX3lR8Fuq2ywl+VJeu5Sf3u5T8Lsk7PXxOx/s9fG7Gez18TuUi9fnvC+8KPjFyH0WM/otiqLFPO3bDIp+5WJz3f1+xua6+2WOqnU/6VssiuTrbnLd/UZJYN1PG6ZH0W+UsNfHb5SuXZ8TpY9fPt1mKf3q6S5Lmfzi6TZL6XdJVy/lWX82JL8eus1S+o3Pr1pKOZP2z3+/msjX5+L1OetHj8kvW26zlH4vc5ul9Cuci5fytN+vJr/Cuc1S+hXOxUv5+U/1st/LYK+PX7Zgr4/foGCvj1+LXLw+J/56NZMv5n0W029RFC3meV8fZb9ysbnufj9jc939MkfVup/1hWT2mx+T605+o3T+up84SIn8Runq9TnrKy/yy6fbLKXfU128lKd95UXkS3mXpfQ7qouX8vPbffK7JOz18Tsf7PXxuxns9fE7lIvX58QvvIpfjNxoMf0WRdFinvdtRvErF5vr7vczNtedfN01rftZ32IVv/mxue5+oySw7ucN6il+o4S9Pn6jdO36nCh9/PLpLktZ/erpNkvpF0+3WUq/S7p6Kc/6s6H69dBtlpJWL2U94owtjB+WciNU0AhVNELL/yhs8dhP7d3XtgehjkZogBFqyxVp6/34uzVOCEU0QsvVQavtjVD/mVBGI7T8pB6H9ItjxJ8JFTRCFY1QQyO0+qROj39wf/ohh54INxr7P11CfVMqdabExvFsDO+FWP2ma9qwEmkPZiKNt4k0huNH2zGkSajJTqjZTqh0o636FmkJP0dabhlpm6xphY60lL1lq1J5EmlqR6ip53eL2r5F2sxEul4mhbdI29NI886j1LcLnTw9kQ4Wj68v//Hupw8TYY5gI8xoI8xkI8xsI0yyEWaxEWa1EWazEaYNFTRMqKASTKigEkyooBJMqKASTKigEshGmCZU0ONGyUaYJlRQCSZUUAk2VFC0oYKiDRUUbaigaEMFRbIRpg0VFG2ooGhDBUUbKijaUEHJhgpKNlRQsqGCkg0VtNw5+aIwbaigZEMFJRsqKNlQQcmGCso2VFC2oYKyDRWUbaig5d6HF4VpQwVlGyoo21BB2YYKyjZUENlQQWRDBZENFUQ2VNByb52LwrShgsiGCiIbKohsqCDCVkHt6BB8P3Ylf+NesKXN59yx9UrPe/9k7/Hzj9fnvZalYCuWEwPF1iwnBkpWAsXWLScGiq1cTgwUW7ucGCi2ejkxUGz9cl6gFVvsnBioFWVUrSijakUZLR+2elmgVpRRtaKMqhVlVK0oo2pFGTUryqhZUUbNijJqVpTR8uHGlwVqRRk1K8qoWVFGzYoyalaUUbeijLoVZdStKKNuRRldMDP6okCtKKNuRRl1K8oIfF70iYFaUUbgM6NPDNSKMgKfG31ioFaUEfjs6BMDtaKMwOdHnxioFWUEPkP6xECNKKMKPkf6xECNKKMKPkv6xECNKKMayEqgRpRRBZ8pfWKgRpRRBZ8rfWKgVpQR+GzpEwO1oozA50ufGKgVZQQ+Y/rEQK0oI/A50ycGakUZgc+aPjFQK8oIfN70iYFaUUbgM6dPDNSKMgKfO31ioFaUEfjs6RMDtaKMwOdPnxioFWUEPoP6xECtKCPwOdQnBmpFGYHPoj4xUCvKCHwe9YmBWlFG4DOpTwzUijICn0t9YqBWlBH4bOoTA7WijMDnU58YqBVlBD6j+sRArSgj8DnVJwZqRRmBj7U+MVArysjKDOxqZQZ2tTIDu1qZgV2tzMCuVmZgVyszsKuVGdjVygzsamUGdrUyA7tamYFdrczArlZmYFcrM7CrlRnY1coM7GplBna1MgO7WpmBXa3MwK5WZmBXKzOwq5UZ2NXKDOxqZQZ2tTIDu1qZgV2tzMCuVmZgVyszsKuVGdjVygzsamUGdrUyA7tamYFdrczArlZmYFcrM7CrlRnY1coM7GplBna1MgO7WpmBXa3MwK5WZmBXKzOwq5UZ2M3KDOxmZQZ2szIDu1mZgd0CWQnUiDJqVmZgNyszsJuVGdjNygzsZmUGdrMyA7tZmYHdrMzAblZmYDcrM7CblRnYzcoM7GZlBnazMgO7WZmB3azMwG5WZmA3KzOwm5UZ2M3KDOxmZQZ2szIDu1mZgd2szMBuVmZgNyszsJuVGdjNygzsZmUGdrMyA7tZmYHdrMzAblZmYDcrM7CblRnYzcoM7GZlBnazMgO7WZmB3azMwG5WZmA3KzOwm5UZ2M3KDOxmZQZ2szIDu1mZgd3Wz8BOND4KdCNErxMqdIRcanpCqNX8/eE26rv0zP7lkXfuo44nz7bSj3+X3p6lb1EWE1HOtUsY+YiyPokyRqr0/ekYW+zH461PHi+jfX+4JnqXkjR5lnr6/mzJbywi/+efU1KO7TlKfRdoG9On6045BPppy7XVWanHluuxPMlKLHH/WMVC+Vleejwijfn9+k/+5TyOtFDOP31YuqdllpbhaZmk5YPh2ubTEj0ts7QkT8ssLdnTMksLeVpmaSmelllaqqdllhZXudO0uMqdpsVV7iwtzVXuNC2ucqdpcZU7TYur3GlayNMyS4ur3GlaXOVO0+Iqd5oWV7nTtLjKnaWlu8qdpsVV7jQtrnKnaXGVO00LeVpmaXGVO02Lq9xpWlzlTtPiKneaFle5s7QMV7nTtLjKnabFVe40La5yp2khT8ssLa5yp2lxlTtNi6vcaVpc5U7T4ip3kpYeXOVO0+Iqd5oWV7nTtLjKnaaFPC2ztLjKnaYFXOW2t7S865yTTwu4yr0qLeAq96q0gKvci9ISwVXuVWkBV7lXpQVc5V6VFnCVe1VayNMySwu4yr0qLa5yp2lxlTtNi6vcaVpc5c7SklzlTtPiKneaFle507S4yp2mhTwts7S4yp2mxVXuNC2ucqdpcZU7TYur3FlasqvcaVpc5U7T4ip3mhZXudO0kKdllhZXudO0uMqdpsVV7jQtrnKnaXGVO0sLucqdpsVV7jQtrnKnaXGVO00LeVpmaXGVO02Lq9xpWlzlTtPiKneaFle5s7QUV7nTtLjKnabFVe40La5yp2khT8ssLdgqt6bd5CvW0hemBVvlXpYWbJV7WVqwVe5lacFWuVelBdz77LK0YKvcy9KCrXIvSwu2yr0sLeRpmaXFVe40La5yp2lxlTtNi6vcaVpc5c7SAu59dllaXOVO0+Iqd5oWV7nTtJCnZZYWV7nTtLjKnabFVe40La5yp2lxlTtLC7j32WVpcZU7TYur3GlaXOVO00KelllaXOVO0+Iqd5oWV7nTtLjKnabFVe4sLeDeZ5elxVXuNC2ucqdpcZU7TQt5WmZpcZU7TYur3GlaXOVO0+Iqd5oWV7mTtAxw77PL0uIqd5oWV7nTtLjKnaaFsNPSj3+5hbYwLeAq96q0gKvcq9ICrnKvSgu4yr0qLeAq96K0gHufXZYWcJV7VVrAVe5VaQFXuVelhTwts7S4yp2mxVXuNC2ucqdpcZU7TYur3FlawL3PLkuLq9xpWlzlTtPiKneaFvK0zNLiKneaFle507S4yp2mxVXuNC2ucmdpAfc+uywtrnKnaXGVO02Lq9xpWsjTMkuLq9xpWlzlTtPiKneaFle507S4yp2lBdz77LK0uMqdpsVV7jQtrnKnaSFPyywtrnKnaXGVO02Lq9xpWlzlTtPiKneWFnDvs8vS4ip3mhZXudO0YKvclvORFgZflhbytMzSgq1yL0sLtsq9LC3YKveytGCr3MvSgq1yr0oLuPfZZWnBVrmXpQVb5V6WFle507SQp2WWFle507S4yp2mxVXuNC2ucqdpcZU7Swu499llaXGVO02Lq9xpWlzlTtNCnpZZWlzlTtPiKneaFle507S4yp2mxVXuLC3g3meXpcVV7jQtrnKnaXGVO00LeVpmaXGVO02Lq9xpWlzlTtPiKneaFle5s7SAe59dlhZXudO0uMqdpsVV7jQt5GmZpcVV7jQtrnKnaXGVO02Lq9xpWlzlTtISA7j52XV5cZ07z4sL3XleXOnO80Kel2leXOvO8+Jid54XV7vzvLjcnefF9e40L+A2aNflxfXuPC+ud+d5cb07zwt5XqZ5cb07z4vr3XlewPVuP9j3d6EuyAu43r0sL+B696q8gBuiXZcXcL17WV7A9e5leQHXu5flhTwv07yA693L8gKudy/Li+vdeV5c787z4np3mhdwa7Tr8uJ6d54X17vzvLjeneeFPC/TvLjenefF9e48L65353lxvTvPi+vdaV7ATdKuy4vr3XleXO/O8+J6d54X8rxM8+J6d54X17vzvLjenefF9e48L653p3kBt0u7Li+ud+d5cb07z4vr3XleyPMyzYvr3XleXO/O8+J6d54X17vzvLjeneYF3Tjtsry43p3nxfXuPC+ud+d5Ic/LNC+ud+d5gda7KR79ainW8Cwvef+Xx7tnUxvfQ10uYTuVnRAvzrtQvxFarh1jHH1/OpX2JPsl7w+X+kY/Tz9m9fhI9v7zh2wYCXS9YdhVgUYrgSYrgWYrgZKVQIuVQKuVQJuVQK0oo2ZFGXUryqhbUUbdijLqVpTRerOmqwK1ooy6FWXUrSijbkUZdSvKaFhRRsOKMhpWlNEAV0Y9h+8P9x4/D/TxLcH+bHq89hZq+x4q2QkVXB2dGSq4PjozVHCFdGao4BrpzFDBVdJ5ocYArpPODBVcKZ0ZKrhWOjNUM2opBrITqhm1FIMZtRSDGbUUgxm1FIMdtRTtqKVoRy1FO2op2lFL6z1GrgvVjlqKdtRStKOWoh21FO2opWRHLSU7ainZUUvJjlpa71BxXah21FKyo5aSHbWU7KilZEctZTtqKdtRS9mOWsp21NJ6f4PrQrWjlrIdtZTtqKVsRy1lO2qJ7KglsqOWyI5aIjtqaf10/OtCtaOWyI5aIjtqieyoJbKjloodtVTsqKViRy0VO2pp/Wz160K1o5aKHbVU7KilYkctFTtqqdpRS9WOWqp21FK1o5bWT+a+LlQ7aqnaUUvVjlpCn8x9Zqh21BL6dO4zQ7WjltAndJ8Zqh21hD6l+8xQ7agl9EndZ4ZqRy2hT+s+M1Q7agl9YveZodpRS+hTu88M1Y5aQp/cfWaodtQS+vTuM0O1o5bQJ3ifGaodtYQ+xfvMUO2oJfRJ3meGakct2ZnlHe3M8o52ZnlHO7O8o51Z3tHOLO9kZ5Z3sjPLO9mZ5Z3szPJOgeyEakYtJTuzvJOdWd7JzizvZGeWd7IzyzvZmeWd7MzyTnZmeSc7s7yTnVneyc4s72RnlneyM8s72ZnlnezM8k52ZnknO7O8k51Z3snOLO9kZ5Z3sjPLO9mZ5Z3szPJOdmZ5JzuzvJOdWd7JzizvZGeWd7IzyzvZmeWd7MzyTnZmeacLZnmnFo5QR/wh1G+U1quanPZ/O+aenmQ/UdzXKpX0xiTmMnl6lFC+Pz1KpXcLMKZP151ICPTTal0wo1tNaqKn5qPUJE/NR6nJnpqPUkOemo9Sc4bq67Ecqen0JDX1QeP70zWk/PnDj3uBvjN5/OEc0/vHvwVQtQcwV2gl7SC5lvx5AKPVfZFH6/UNYvbxya3tH7bcae2Hra8NlVJo3x+mVNvSUMfrofZ4hNopvg91g/hgbvdvgwj5U4h4AkRJb4kq5fMVi6Me6/v4z728urs+GIOtKYK8PILW2xHBGO0fKOXw+/k3K+mxr/ZQHi++bbcU9/fqF99rX3yvf/G98bX35le7v+K9+MX3pp/ux/fxx3uPDfDDe5NyFvfFrm08eZY/Gm+fjLdTL/a2M8pwjAiOUYFjVOEYNThGHY7RQGM0v9S5lFGEYwR3ZhPcmU1wZzbBndkEd2YT3JlNcGc2wZ3ZBe7MLnBndoE7swvcmV3gzuwCd2YXuDO7wJ3ZdfHuL21/tvS3Z1PNO58Exmfxp/px3X3cdtcZnwrGp4Hx6WB8BhafJqo/vmPEBRgnnBPt+B6qJZph5AUYtACjLMCoCzDaAoy+AOOEM6GV/XuMHp6rgPSmAnKbqIAe4BhFOEYJjlGGY0RwjMpqRuX4ccOoM8XdKxyjBseowzEaaIxGgGMU4RgtP7Pf/b3dZ+fRyHCMCI5RgWNU4Rg1OEYdjtG4kNH0ti2GgEcp4lE64djuaXx/eLT25Wd3QhmNEKERKmiEKhqhhkaooxEaYIRiQCMU0QihndQR7aSOaCd1RDupI9pJHdFO6oh2Uke0kzqhndQJ7aROaCd1QjupE9pJndBO6rT4HHr244yYBhihvHiXPfu6P+aMRojQCBU0QhWNkKge2kH6ApCSwM6LktEIERqhgkaoohFa/OdKjftlb33Xj/+eUEcjNMAI1YBGKKIRWi6kxkGIpoQyGiFCI1TQCFU0Qg2NUAeTmnWAEWoBjVBEI4T2J29D+5O3ERohtD95G9qfvK2hEUI7qRvaSd3RTuqOdlJ3tJO6o53UHe2k7mgndUc7qTvaSd3RTuqOdlIPtJN6oJ3UA+2kHmgn9UA7qQfaST3QTuqBdlIPtJN6gJ3UKYCd1CmAndQpgJ3UKYCd1CmAndQpgJ3UKYCd1CksHlrx7CvOFAMaIbCxOSmCzc1JMaMRorWEnn3FmWJBI1TRCDU0Qh2N0PLxQp9/o5hSQCMU0QglNEIZjRChEQIbAveBAfGVhMDGwKUENgcuJbBBcB8Y415JKKIRSmiEMhohQiOEdlJntJM6o53UGe2kzmgnNaGd1IR2UhPaSU1oJzWhndSEdlIT2klNaCc1oZ3UhHZSF7STuqCd1AXtpC5oJ3VBO6kL2kld0E7qgnZSF6STOvX6gRVlO4yYW3u73o6xH6+1r73Wv/ba+NJr84uU56/Fr72Wvvba9Jjrcbc17Wn+Gn3ttfK11+rXXmtfe61/7bXxpdfmf8T1w462jzR9LX7ttfS11/LXXqOvvVa+9lr92mvTT8kI8ftrI4bpa/1rr40vvTYXkM9fi197LX3ttfy116afknE4K4883Thz+fH8tfq119rXXutfe2186bV5+/jz1+KT12i6bvNW7Oev5a+9Nv+UHANmR53u7nnz8fPX6tdea197rX/ttfGl1+atq89fm39K+q7wYij9h/d+91se3kHSCpC8AoRWgJQVIHUFSFsB0leAjAUg86bGs0FW7Pi+Ysf3FTu+r9jxfcWO7yt2fF+x4/uKHd9X7PixYsePFTt+rNjxY8WOHyt2/Hh9n3z6G+gNo8tjfGAo8ZtAnt4nfmARcTZIXgFCK0DKCpDfWk6OF9sXX0x5wec50QqQsgKkrgBpK0BeP8g+/W39N5CxACSHFSBxBUhaAXLGkfzJz72/gdAKkLICpK4AaStA+gqQsaBMUlgBskKE0QoRRitEGK0QYbRChFFdAdJWgPQVICt2fFmx48uKHV9W7PiyYseXFTu+rNjxZcWOLyt2fFmx48uKHV9X7Pi6YsfXFTu+rtjxdcWOryt2fF2x4+uKHV9X7Pi6Yse3FTu+rdjxbcWObyt2fFux49uKHd9W7PgmveNH+v0U4qGTDkvo0t4w+A7op4d7nf3Qb/rog2Pd/930/kKJdjodi87AojMfu3QhnwjGJ4HxyWB8CIxPAeNTwfiAnc4R7HiOYOdzAjufE9j5nMDO5wR2Piew8zmBnc9J8HzeIZo8xOun6Ijp+7OD4stZHVh8cgDjE8H4JDA+GYwPgfEpYHwqGJ8GxgfsfM5g5zOBnc8Edj4T2PlMYOczgZ3PBHY+E9j5TILn8w7R5SGGOEQJ8hBRHiLJQ2R5CJKHKPIQVR5CfnfX1z+0MRzzPGJ4f0q9gaQVIK8veUylHedtm90P1LEgkhZWgKxY+EYngLz7TnW0GUhZAVJXgLQVIH0FyBn7pKU3kD4B6WEFSFwBklaA5BUgtAKkrACpK0DaCpC+AuSEHf+ov/vDsczUyggrQOIKkLQCJK8AoRUgZQVIXQHSVoCcsOPjMSQuxjFmIGMBSAxhCUpe8MfDB+3rp6OUJSh1CcpYgXLCb/d+DUpcgpKWoMjvF5r//rUdb7X+5PqUws6GUvn80X7ImxHetbvSFy5laf5DWQW8h1Le8+2rgXjUSjxpJZ61EietxItW4lUrca11M2otnFFr5UxaK2fSWjmT1sqZtFbOpLVyJq2VM4lVzh2gSQO8XImOyeFUaAYwhAFykAaI0gBJGuDlE63vm4Z6ngGQNECRBqjSAK/u5BKO8YehzwC6NMAQBqAgDRClAV79mJa0V5ySpgBVGuDVRa75GKdXZledJUgDSKeovLyT6fgUlTYD6NIAQxigBmmAKA2QpAGyNABJAxRpgCoNcOJOrnUG0KUBXt/Jx2HXZgDt5Z18HNcfAERpgCQN8OpOruGYbxzGDICkAYo0QJUGaNIAL+/ksf+Spb4zwnsHMIQBepAGiNIASRogSwOQNECRBqjSAO1EgNlO7l0a4PWdvDcb1DQDGC/v5ONe8wOAKA2QpAFerslP/socJA1QpAGqNECTBujSANKXIR/85vMkhBw++GVZrHT8rLb++HfF5FsQise3IJRmGB/8qPC3gZRxgPQnD582zWcjHzWTT5rJZ83kSTP5opl81Uy+aSbfNZMfisknzRU2aa6wSXOFTZorbNJcYZPmCps0V9ikucImzRU2oVTY73wyStHc+Syug6eN39rIJ83ks2bypJl80Uy+aibfNJPvmskPxeQpaCavucKS5gpLmissaa6wpLnCkuYKS5orLGmusKS5whaUCrvzQSmaOx+UOrjzQSltOx+UarXzQSlAOx+UmrLzQSkTOx+Uk3/ng3KYf+dTwc7nuni/fz7reGNU4Bgt/kx/PtFr+91VRMtRS3CMMhyjuprRZ+OlN0YNjlGHYzTQGPUAx2j5efTZGOWNUYJjlOEYERyjAseowjFqcIw6HKOBxmgEOEarz+xPp21vjBIcowzHiOAYFThGFY5Rg2PU4RgNNEYfzcwXpPTZgP1vlCIepYRHqaDd2Hw05/9SSg2PEtxVW1zdwvdrKCU8ShmPEuFRwjqXYlTpDcG8NY64Zt4aJ1wzb5XeEBtxjROuN+IaJ1xvxDVOuN6Ik1biGidcb8Q1ekNsxLXWTZXeEBtxrZVTpTfERlxr5VTpDbER11o5VXpDbMS1Vk5Rb4gNoEkDSHpDbABDGEDUG2IDiNIASRpA0htiAyBpgCINUKUBJL0hNoAuDTCEAUS9ITaAKA0g6Q2xAVRpAMlxiAwg6g2xAUinSNQbYgPo0gBDGEDUG2IDiNIASRogSwOQNECRBqjSAJLeEBtAlwaQ9IbYvpmS9IbYAKI0QJIGkPSG2ABIGqBIA1RpgCYNIOkNsQEMYQBRb4gNIEoDJGmALA1A0gBFGqBKA0h6Q2wAXRpA0hti+/WCpDfEBhClAZI0gKQ3xAZA0gBFGqBKAzRpgC4NIH0ZIuwNkYK8N8QDQ683BJNXO7mayaudXM3k1U6uZvKkmbzaydVMXu3kaiavdnI1k1c7uZrJq/WGeJDX6w3B5DVXWL3eEExec4XV6w3B5DVXWL3eEExec4XV6w3B5JG8IR58oLwhmI/aydVMXu3kaiavdnI1kyfN5NVOrmbyaidXM3m1k6uZvNrJ1Uxe7eTqB3m93hBMXnOF1esNweQ1V1i93hBMXnOF1esNweQ1V1i93hBMXnOFhfKGYD5I3hDMB8kbgvkgeUMwH5RqtfNB8oZgPkjeEMwHyRuC+SB5QzAfJG+IBx8obwjms3i/P5mgz4ywvCGYEdbAOv7dFZY3BDPC8oZgRljeEMwIyxuCGWF5QzAjLG8IZoTlDfFgBOYNwYywvCGYEZY3BDPC8oZgRgTHCMsbghlheUMwIyxvCGaE5Q3BjLC8IR6MwLwhmBGWNwQzwvKGYEZY3hDMiOAYYXlDMCMsbwhmhOUNwYywvCGYEZY3xNZ5hOUNsVHC8obYKGF5Q2yUsGawb5SwvCE2SljeEBsluKs2NG+IjRKWN8RGCcsbYqNEeJTAzqW2oIO3ae7gbZo7eJvmDt6muYO3ae7gbZo7eJvmDt6muYO3ae7gbZo7eJvmDt6muYO3ae7gbZo7eJvmDt6muYO3ae7gbZo7eJvmDt4G1sHbwDp4m+YO3qa5g7dp7uBtmjt4m+YO3qa5g7dp7uBtmjt4m+YO3qa5g7dp7uBtmjt4m+YO3qa5g7dp7uBtmjt4m+YO3qa5g7dp7uBtYB28DayDt4F18DawDt4G1sHbwDp4G1gHbwPr4G1gHbwNrIO3gXXwNrgO3gbXwdvgOngbXAdvg+vgbXAdvA2ug7fBdfA2uA7eBtfB2+A6eBtcB2+D6+BtcB28Da6Dt8F18Da4Dt4G18Hb4Dp4G1wHb4Pr4G1wHbwNroO3wXXwNrgO3gbXwdvgOngbXAdvg+vgbXAdvA2vg7fhdfA2vA7ehtfB2/A6eBteB2/D6+BteB28Da+Dt+F18Da8Dt4G18Gby+9f9UGm0L8/Sql8/mg//iIZgd4epd/+PfeDd1fKeyjlHYNW4lEr8aSVeNZKnLQSL1qJV63EtdbNqLVwRq2VM2mtnElr5UxaK2fSWjmT1sqZtFbOJFY5d4AmDfByJSr7NSAVmgEMYYAcpAGiNECSBnj5ROv7pqGeZwAkDVCkAao0wKs7uYT90RL6DKBLAwxhAArSAFEa4NWPaUl7xSlpClClAV5d5Jr3i9FaZledJUgDSKeovLyT6fgUlTYD6NIAQxigBmmAKA2QpAGyNABJAxRpgCoNcOJO/vEbox2gSwO8vpOPw67NANrLO/k4rj8AiNIASRrg1Z1cwy7faxgzAJIGKNIAVRqgSQO8vJPH/u1yjWEGMIQBepAGiNIASRogSwOQNECRBqjSAO1EgNlO7l0a4PWdvLew1TQDGC/v5ONe8wOAKA2QpAFerslP/socJA1QpAGqNECTBujSANKXIR/8tvksBCry3hBUFHtDUFHsDUFFsTcEFcXeEFQUe0NQUewNQUWxNwQVxd4QVBR7Q1BR7A1BRbE3BBXF3hBUFHtDUFHsDUFFsTcEFcXeEFQUe0NQUewNQUWxNwQVLG8IKljeEFQUe0NQUewNQUWxNwQVxd4QVBR7Q1BR7A1BRbE3BBXF3hBUFHtDUFHsDUFFsTcEk9dcYfV6QzB5zRVWrzcEFcXeEExec4XV6w1BRbE3BBUsbwjmg+QNwXyQvCGYD5I3BPNBqVY7HyRvCCpY3hBUsLwhqGB5Q1DB8oagguUNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1CB84bYKGF5Q2yUsLwhNkpYM9g3SljeEBslLG+IjRLcVRuaN8RGCcsbYqOE5Q2xUSI8SljnUkk6vSEevFWOuH7wVjnh+sFbpzcEE1c54ZqJq5xwzcRVTrhm4qSVuMoJ10xcpTcEE9daN3V6QzBxrZVTpzcEE9daOXV6QzBxrZVTpzcEE9daOWW9IRigSQOIekMwwBAGkPWGYIAoDZCkAUS9IRiApAGKNECVBhD1hmCALg0whAFkvSEYIEoDiHpDMECVBhAdh/gAkPWGYADpFMl6QzBAlwYYwgCy3hAMEKUBkjRAlgYgaYAiDVClAUS9IRigSwOIekPwN1Oi3hAMEKUBkjSAqDcEA5A0QJEGqNIATRpA1BuCAYYwgKw3BANEaYAkDZClAUgaoEgDVGkAUW8IBujSAKLeEPzrBVFvCAaI0gBJGkDUG4IBSBqgSANUaYAmDdClAaQvQ4S9IWqU94Z4YOj1hmDyaidXM3m1k6uZvNrJ1UyeNJNXO7mayaudXM3k1U6uZvJqJ1czebXeEA/yer0hmLzmCqvXG4LJa66wer0hmLzmCqvXG4LJa66wer0hmDySN8SDD5Q3BPNRO7mayaudXM3k1U6uZvKkmbzaydVMXu3kaiavdnI1k1c7uZrJq51c/SCv1xuCyWuusHq9IZi85gqr1xuCyWuusHq9IZi85gqr1xuCyWuusFDeEMwHyRuC+SB5QzAfJG8I5oNSrXY+SN4QzAfJG4L5IHlDMB8kbwjmg+QN8eAD5Q3BfBbv9ycT9JkRljcEM8IaWMe/u8LyhmBGWN4QzAjLG4IZYXlDMCMsbwhmhOUNwYywvCEejMC8IZgRljcEM8LyhmBGWN4QzIjgGGF5QzAjLG8IZoTlDcGMsLwhmBGWN8SDEZg3BDPC8oZgRljeEMwIyxuCGREcIyxvCGaE5Q3BjLC8IZgRljcEM8Lyhtg6j7C8ITZKWN4QGyUsb4iNEtYM9o0SljfERgnLG2KjBHfVhuYNsVHC8obYKGF5Q2yUCI8S2LnUF3Twds0dvF1zB2/X3MHbNXfwds0dvF1zB2/X3MHbNXfwds0dvF1zB2/X3MHbNXfwds0dvF1zB2/X3MHbNXfwds0dvF1zB2/X3MHbwTp4O1gHb9fcwds1d/B2zR28XXMHb9fcwds1d/B2zR28XXMHb9fcwds1d/B2zR28XXMHb9fcwds1d/B2zR28XXMHb9fcwds1d/B2zR28HayDt4N18HawDt4O1sHbwTp4O1gHbwfr4O1gHbwdrIO3g3XwdrAO3g7XwdvhOng7XAdvh+vg7XAdvB2ug7fDdfB2uA7eDtfB2+E6eDtcB2+H6+DtcB28Ha6Dt8N18Ha4Dt4O18Hb4Tp4O1wHb4fr4O1wHbwdroO3w3XwdrgO3g7XwdvhOng7XAdvh+vg7XAdvB2ug7fjdfB2vA7ejtfB2/E6eDteB2/H6+DteB28Ha+Dt+N18Ha8Dt6O18Hb4Tp4e/igg7eUvr9WWv8c47xfeT/odCw6A4vOB63Q1/GJYHwSGJ8MxofA+BQwPhWMD9jpHMGO5wh2Piew8zmBnc8J7HxOYOdzAjufE9j5nATP5x2iyUO8foqe95NR5jOw+OQAxieC8UlgfDIYHwLjU8D4VDA+DYwP2Pmcwc5nAjufCex8JrDzmcDOZwI7nwnsfCaw85kEz+cdostDDHGIEuQhojxEkofI8hAkD1HkIao8hPzurq9/aJ/8uJ5B0gqQ15f8+VdydSyIpIUVICsWvtEJIJ/+wJ1BygqQugKkrQDpK0DO2Cef/kqWv5AOK0DiCpC0AiSvAKEVIGUFSF0B0laA9BUgJ+z4z3/1yb/5CCtA4gqQtAIkrwChFSBlBUhdAdJWgJyw4z//JS+DjAUgH/3O+2yUvOCPhxhoCUpZglKXoIwVKCf8du/XoMQlKGkJivx+SfPfv7bjrdafXJ9S2NlQKp8/2g95MwL9/d0962+/lE3zH8oq4D2U8p5vXw3Eo1biSSvxrJU4aSVetBKvWolrrZtRa+GMWitn0lo5k9bKmbRWzqS1ciatlTNprZxJrHLuAE0a4OVKVPYbJyo0AxjCADlIA0RpgCQN8PKJ1vdNQz3PAEgaoEgDVGmAV3dyCfujJfQZQJcGGMIAFKQBojTAqx/TkvaKU9IUoEoDvLrINe+DAWqZXXWWIA0gnaLy8k6m41NU2gygSwMMYYAapAGiNECSBsjSACQNUKQBqjTAiTv5x4kpO0CXBnh9Jx+HXZsBtJd38nFcfwAQpQGSNMCrO7mGXb7XMGYAJA1QpAGqNECTBnh5J4/9lyw1hhnAEAboQRogSgMkaYAsDUDSAEUaoEoDtBMBZju5d2mA13fy3mxQ0wxgvLyTj3vNDwCiNECSBni5Jj/5K3OQNECRBqjSAE0aoEsDSF+GfPCbz7MQxge/LPuNox7j8S0IpRlGRDGh/81f4YyPfpmkhXzSTD5rJk+ayRfN5Ktm8k0z+a6Z/FBMPmmusElzhU2aK2zSXGGT5gqbNFfYpLnCJs0VNmmusAmlwn7nk1GK5s4HxYT+K4ubURzrv0Qexd7+S+RJM/mimXzVTL5pJt81kx+KyVPQTF5zhSXNFZY0V1jSXGFJc4UlzRWWNFdY0lxhSXOFLSgVdueDUjR3Pih1cOeDUtp2PijVaueDUoB2Pig1ZeeDUiZ2Pign/84H5TD/zqeCnc918X5/Mut4fNT4cSkjLMPm8VFbw5U5agmOUYZjtNoe/fPx0uOjxoZLGXU4RgONUQ9wjJafR5+OUR4fdXNcyijDMSI4RgWOUYVj1OAYdThGA43RCHCMVp/Zn0/bHh/17VzKKMMxIjhGBY5RhWPU4Bh1OEYDjdFHM/MFKX06YH+jFPEoJTxKBe3G5qM5/5dSaniU4K7a4uoWvl9DKeFRyniUCI8S2Lk0dHpDPHirHHH94K1ywvWDt05vCCaucsI1E1c54ZqJq5xwzcRJK3GVE66ZuEpvCCautW7q9IZg4lorp05vCCautXLq9IZg4lorp05vCCautXLKekMwQJMGEPWGYIAhDCDrDcEAURogSQOIekMwAEkDFGmAKg0g6g3BAF0aYAgDyHpDMECUBhD1hmCAKg0gOg7xASDrDcEA0imS9YZggC4NMIQBZL0hGCBKAyRpgCwNQNIARRqgSgOIekMwQJcGEPWG4G+mRL0hGCBKAyRpAFFvCAYgaYAiDVClAZo0gKg3BAMMYQBZbwgGiNIASRogSwOQNECRBqjSAKLeEAzQpQFEvSH41wui3hAMEKUBkjSAqDcEA5A0QJEGqNIATRqgSwNIX4bIekM87v7FvSEYQ603xEZe6+TqjbzWydUbea2TqzfypJm81snVG3mtk6s38lonV2/ktU6u3shr9YZg8mq9ITbymiusWm+IjbzmCqvWG2Ijr7nCqvWG2MhrrrBqvSE28kDeEMwHyRti46N1cvVGXuvk6o281snVG3nSTF7r5OqNvNbJ1Rt5rZOrN/JaJ1dv5LVOrmbyar0hNvKaK6xab4iNvOYKq9YbYiOvucKq9YbYyGuusGq9ITbymisskjfExgfIG2LjA+QNsfEB8obY+KBUq50PkDfExgfIG2LjA+QNsfEB8obY+AB5QzAfJG+Ijc/i/f75BP2NEZQ3xMYIamDd9rsrKG+IjRGUN8TGCMobYmME5Q2xMYLyhtgYQXlDbIygvCGYEZY3xMYIyhtiYwTlDbExgvKG2BgRHCMob4iNEZQ3xMYIyhtiYwTlDbExgvKGYEZY3hAbIyhviI0RlDfExgjKG2JjRHCMoLwhNkZQ3hAbIyhviI0RlDfExgjKG+Jb5xGUN8Q3SlDeEN8oQXlDfKMENYP9GyUob4hvlKC8Ib5RgrtqA/OG+EYJyhviGyUob4hvlAiPEta5FIt8B+8DQ28HL5NX21/E5NX2FzF5tf1FTJ40k1fbX8Tk1fYXMXm1/UVMXm1/EZNX28H7IK+3g5fJa66wejt4mbzmCqu3g5fJa66wejt4mbzmCqu3g5fJI3XwPvhAdfAyH7X9RUxebX8Rk1fbX8TkSTN5tf1FTF5tfxGTV9tfxOTV9hcxebX9RQ/yejt4mbzmCqu3g5fJa66wejt4mbzmCqu3g5fJa66wejt4mbzmCgvVwct8kDp4mQ9SBy/zQergZT4o1Wrng9TBy3yQOniZD1IHL/NB6uBlPkgdvA8+UB28zGfxfn/S58iMsDp4mRHWzwr5d1dYHbzMCKuDlxlhdfAyI6wOXmaE1cHLjLA6eJkRVgfvgxFYBy8zwurgZUZYHbzMCKuDlxkRHCOsDl5mhNXBy4ywOniZEVYHLzPC6uB9MALr4GVGWB28zAirg5cZYXXwMiOCY4TVwcuMsDp4mRFWBy8zwurgZUZYHbxb5xFWB+9GCauDd6OE1cG7UYLrlEPr4N0oYXXwbpTgrtrQOng3SlgdvBslrA7ejRLhUcI6l1L+/as+yBT690cplc8f7cdfJCPQ26P027/nfvDuSnkPpbxj0Eo8aiWetBLPWomTVuJFK/GqlbjWuhm1Fs6otXImrZUzaa2cSWvlTForZ9JaOZPWypnEKucO0KQBXq5EZb8GpEIzgCEMkIM0QJQGSNIAL59ofd801PMMgKQBijRAlQZ4dSeXsD9aQp8BdGmAIQxAQRogSgO8+jEtaa84JU0BqjTAq4tc834xWsvsqrMEaQDpFJWXdzIdn6LSZgBdGmAIA9QgDRClAZI0QJYGIGmAIg1QpQFO3Mk/fmO0A3RpgNd38nHYtRlAe3knH8f1BwBRGiBJA7y6k2vY5XsNYwZA0gBFGqBKAzRpgJd38ti/Xa4xzACGMEAP0gBRGiBJA2RpAJIGKNIAVRqgnQgw28m9SwO8vpP3FraaZgDj5Z183Gt+ABClAZI0wMs1+clfmYOkAYo0QJUGaNIAXRpA+jLkg982n4WQs7w3RM6KvSFyVuwNkbNib4icFXtD5KzYGyJnxd4QOSv2hshZsTdEzoq9IXJW7A2Rs2JviJwVe0PkrNgbImfF3hA5K/aGyFmxN0TOir0hclbsDZGzYm+InLG8IXLG8obIWbE3RM6KvSFyVuwNkbNib4icFXtD5KzYGyJnxd4QOSv2hshZsTdEzoq9IXJW7A3B5DVXWL3eEExec4XV6w2Rs2JvCCavucLq9YbIWbE3RM5Y3hDMB8kbgvkgeUMwHyRvCOaDUq12PkjeEDljeUPkjOUNkTOWN0TOWN4QOWN5Q+SM5g2RM5o3RM5o3hA5o3lD5IzmDZEzmjdEzmjeEDmjeUPkjOYNkTOaN0TOaN4QOaN5Q+SM5g2RM5o3RM5o3hA5o3lD5IzmDZEzmjdEzmjeEDmjeUPkjOYNkTOaN0TOaN4QOaN5Q+SM5g2RM5o3RM5o3hA5o3lD5IzmDZEzmjdEznDeEBslLG+IjRKWN8RGCWsG+0YJyxtio4TlDbFRgrtqQ/OG2ChheUNslLC8ITZKhEcJ61yioNMb4sFb5YjrB2+VE64fvHV6QzBxlROumbjKCddMXOWEayZOWomrnHDNxFV6QzBxrXVTpzcEE9daOXV6QzBxrZVTpzcEE9daOXV6QzBxrZVT1huCAZo0gKg3BAMMYQBZbwgGiNIASRpA1BuCAUgaoEgDVGkAUW8IBujSAEMYQNYbggGiNICoNwQDVGkA0XGIDwBZbwgGkE6RrDcEA3RpgCEMIOsNwQBRGiBJA2RpAJIGKNIAVRpA1BuCAbo0gKg3BH8zJeoNwQBRGiBJA4h6QzAASQMUaYAqDdCkAUS9IRhgCAPIekMwQJQGSNIAWRqApAGKNECVBhD1hmCALg0g6g3Bv14Q9YZggCgNkKQBRL0hGICkAYo0QJUGaNIAXRpA+jJE2BuChrw3xANDrzcEk1c7uZrJq51czeTVTq5m8qSZvNrJ1Uxe7eRqJq92cjWTVzu5msmr9YZ4kNfrDcHkNVdYvd4QTF5zhdXrDcHkNVdYvd4QTF5zhdXrDcHkkbwhHnygvCGYj9rJ1Uxe7eRqJq92cjWTJ83k1U6uZvJqJ1czebWTq5m82snVTF7t5OoHeb3eEExec4XV6w3B5DVXWL3eEExec4XV6w3B5DVXWL3eEExec4WF8oZgPkjeEMwHyRuC+SB5QzAflGq180HyhmA+SN4QzAfJG4L5IHlDMB8kb4gHHyhvCOazeL8/maDPjLC8IZgR1sA6/t0VljcEM8LyhmBGWN4QzAjLG4IZYXlDMCMsbwhmhOUN8WAE5g3BjLC8IZgRljcEM8LyhmBGBMcIyxuCGWF5QzAjLG8IZoTlDcGMsLwhHozAvCGYEZY3BDPC8oZgRljeEMyI4BhheUMwIyxvCGaE5Q3BjLC8IZgRljfE1nmE5Q2xUcLyhtgoYXlDbJTAZrAPOG+IjRKWN8RGCe6qDc0bYqOE5Q2xUcLyhtgoER4lrHOpVPkO3geG3g5eJq+2v4jJq+0vYvJq+4uYPGkmr7a/iMmr7S9i8mr7i5i82v4iJq+2g/dBXm8HL5PXXGH1dvAyec0VVm8HL5PXXGH1dvAyec0VVm8HL5NH6uB98IHq4GU+avuLmLza/iImr7a/iMmTZvJq+4uYvNr+Iiavtr+IyavtL2LyavuLHuT1dvAyec0VVm8HL5PXXGH1dvAyec0VVm8HL5PXXGH1dvAyec0VFqqDl/kgdfAyH6QOXuaD1MHLfFCq1c4HqYOX+SB18DIfpA5e5oPUwct8kDp4H3ygOniZz+L9/qTPkRlhdfAyI6yfFfLvrrA6eJkRVgcvM8Lq4GVGWB28zAirg5cZYXXwMiOsDt4HI7AOXmaE1cHLjLA6eJkRVgcvMyI4RlgdvMwIq4OXGWF18DIjrA5eZoTVwftgBNbBy4ywOniZEVYHLzPC6uBlRgTHCKuDlxlhdfAyI6wOXmaE1cHLjLA6eLfOI6wO3o0SVgfvRgmrg3ejBNcph9bBu1HC6uDdKMFdtaF18G6UsDp4N0pYHbwbJcKjBHUuPc6k9kH/TD1qYwtvV5kxtrf30hffy198j774Xvnt76WPHWAfmuCoPam9ezN9e7PkD5o3a47fX+zpPWL8+z8//tv//cN//ekP//Iff/zr4w3+H//7z//6tz/95c/f/+vf/t9/fvtfHs/+fw=="}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::constructor_parameters"}}],"kind":"struct","path":"TokenBridge::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_public_parameters"}}],"kind":"struct","path":"TokenBridge::claim_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_private_parameters"}}],"kind":"struct","path":"TokenBridge::claim_private_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::get_token_abi"}]}},"file_map":{"106":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"107":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"111":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n"},"112":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"117":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"118":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"119":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"121":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"129":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"132":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"134":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"135":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"137":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point { x: x_coordinate, y: y_coordinate, is_infinite: false }\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"142":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"147":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once. \n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"157":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"187":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"196":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"202":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"23":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"251":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"261":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"263":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"264":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"267":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"268":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"271":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"272":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"276":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"279":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"291":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n"},"293":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"305":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk, from));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"318":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr","source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"34":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"43":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"49":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"52":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"56":{"path":"/Users/offbeatkey/Documents/Noir/asp-aztec-bridge/packages/aztec-contracts/token_bridge/src/main.nr","source":"// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        //recomputes the L1->L2 message. Does the same thing as the Tokenportal.sol's deposit function for the content_hash\n        //important: to and amount is included here. If attackers input their own address, the content hash will be different \n        //to what the token portal had calculated on L1.\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash, //The content - which is reconstructed in the get_mint_public_content_hash()\n            secret, //The secret used for consumption, often 0 for public messages\n            storage.portal_address.read_public(), //Who on L1 sent the message. Which should match the stored portal_address in our case as we only want to allow messages from a specific sender.\n            message_leaf_index //The index in the message tree of the message.\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n\n    //Withdrawing from L1\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        //*passes this content to the kernel circuit which creates the proof for the transaction\n        //*takes the recipient and content as input, and will insert a message into the outbox. We set the recipient to be the portal address read from storage of the contract.\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens on L2: We burn the tokens from the msg_sender(). Otherwise, a malicious user could burn someone elses tokens and mint tokens on L1 to themselves. \n        //One could add another approval flow on the bridge but that might make it complex for other applications to call the bridge.\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately (similar to the public version but instead its burning/nullify the users private notes)\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress, //note, since its a private function, we dont have access to storage. To circumvent this, define as a param and pass it down to the internal public function and ensure the address is the same as the storage\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n}"},"62":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\npub fn compute_inner_note_hash<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"71":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"75":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"77":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"78":{"path":"/Users/offbeatkey/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{enqueue_public_function_call_internal, set_public_teardown_function_call_internal}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}